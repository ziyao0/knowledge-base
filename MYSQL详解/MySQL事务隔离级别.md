# [MySQL事务隔离级别](../README.md)

[TOC]

## 一 概述

数据库一般在执行多个事务并发的对一批数据执行增删改查的操作时，可能会导致常见的脏读、脏写、不可重读读、幻读等问题。造成这些问题的本质都是数据库的多个事务并发问题，未解决事务并发问题数据库设计了**事务隔离机制、锁机制、MVCC(多版本并发控制隔离机制)**用来解决多事务并发问题。

## 二 事务及其ACID属性

> 事务是有sql语句组成的逻辑处理单元，事务具有一下个属性，通常简单的称为事务的ACID属性。

+ 原子性：事务是一个原子操作单元，对数据的修改要么全部执行成功，要么不执行。
+ 一致性：在事务开始和完成时，数据都必须保持一致的状态。这意味着所有相关的数据都必须应用于事务的修改，以保证数据的完整性。
+ 隔离性：保证事务在不受外部并发操作影响的独立环境执行，这意味着事务处理过程中的中间状态对外部是不可见的,反之亦然。
+ 持久性：事务完成之后，它对数据的修改是永久性的，即时出现系统故障也能保持。

### 1 并发事务带来的问题

+ **脏写：**当两个或者多个事务去操作同一行数据，然后基于最初选定的值更行该行数据时，由于每个事务都不知道其他事务的存在，就会发生丢失更新的问题。也就是最后的更新覆盖了由其他事务更新的内容。
+ **脏读：**事务B读取到了事务A新增但未提交的数据。
+ **不可重复读：**事务A相同的查询语句在不同时刻读了不同的值，不符合事务的隔离性。
+ **幻读：**事务A读取到了事务B提交的新增数据，不符合事务的隔离性。

### 2 事务的隔离级别

| 隔离级别                   | 脏读(dirty read) | 不可重复读(nonRepeatable read) | 幻读 (phantom read) |
| -------------------------- | ---------------- | ------------------------------ | ------------------- |
| 读未提交(read uncommitted) | yes              | yes                            | yes                 |
| 读已提交(read committed)   | no               | yes                            | yes                 |
| 可重复的(repeatable read)  | no               | no                             | yes                 |
| 可串行化(serializable)     | no               | no                             | no                  |

数据库的事务隔离级别越严格，并发副作用就越小。但付出的性能成本就会越大。因为事务隔离级别就是使事务在一定程度上串行化执行，这与并发操作显然是互相矛盾的。同时不同的应用对事务的隔离程度的要求也是不同的，比如不可重复度和幻读并不明显，可能更关心数据的并发访问能力。

~~~sql
#查看数据库事务隔离级别
show variables like 'tx_isolation';
#设置事务隔离级别
set tx_isolation='REPEATABLE-READ';
~~~

## 三 锁详解

​	锁是计算机协调多个进程或线程并发访问某一个资源的机制。在数据库中，除了传统的计算资源的争用以外，数据也是一种需要用户共享的资源。加锁也是一种保证数据并发访问一致性、有效性的方式，但是锁在某种程度上也是影响数据库并发访问性能的一个重要因素。

### 1 锁分类

a.从性能上可以把锁分为`乐观锁`（基于版本号对比实现）和`悲观锁`。

b.从数据库操作可以分为`读锁`和`写锁`（都属于悲观锁）。

+ 读锁(共享锁、S锁(Shared)):针对同一份数据，多个操作可以同时进行而不会相互影响
+ 写锁（排它锁、X锁(eXclusive)）:当前操作没有完成前，会阻断其他写锁和读锁

c.从对数据操作的力度可以分为`表锁`和`行锁`。

+ 表锁：每次操作都会锁住整张表，开销小，加锁快；不会出现死锁；锁定粒度大，发生所冲突的概率最高，并发性能最低；应用场景一般是在数据迁移时使用
+ 行锁：每次操作只锁住一行数据，开销大、加锁慢；会出现死锁，锁定力度小，发生锁冲突的概率最低，并发最高。
  + innoDB支持事务、支持行级锁
  + myisam不支持事务，只支持表锁

~~~sql
#添加表锁操作
lock table user_table read,test_table write;
#查看是否有表锁
show open tables;
# 删除表锁
unlock tables;
~~~

无索引行锁会升级为表锁（**RR（读已提交）级别会升级为表锁，RC（可重复读）级别不会升级为表锁**）。

锁主要加载索引上，如果对非索引字段进行更新，行锁会升级为表锁。

**InnoDB的行锁是针对索引进行加锁，而不是针对一行记录记性加锁，并且索引不能失效，否则行锁会升级为表锁。**

### 2 间隙锁（Gap Lock）

间隙锁就是锁的两个值之间的空隙。mysql默认隔离级别为repeatable-read，而间隙锁在repeatable-read的基础上一定程度的能解决幻读的为题。比如在更新数据是添加一个范围条件，mysql会在值之间的范围也会加上锁，这种锁别称为`间隙锁`.

### 3 临键锁（next-key Locks）

Next-Key Locks是行锁与间隙锁的组合。像上面那个例子里的这个(3,20]的整个区间可以叫做临键锁。

### 4 行锁分析

通过检查innodb_row_lock状态变量来分析系统上的行锁情况

~~~sql
show status like 'innodb_row_lock%';
~~~

数据说明：

+ Innodb_row_lock_current_waits：当前正在等待锁定的数量
+ Innodb_row_lock_time：从系统启动到当前时间锁定总时长
+ Innodb_row_lock_time_avg：每次锁等待所花费平均时间
+ Innodb_row_lock_time_max：从系统启动到当前时间等待最长的一次所花费时间
+ Innodb_row_lock_waits：从系统启动到现在总共等待次数

对于这5个状态变量，比较重要的主要是：

Innodb_row_lock_time_avg （等待平均时长）

Innodb_row_lock_waits （等待总次数）

Innodb_row_lock_time（等待总时长）

尤其是当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手制定优化计划。

**查看INFORMATION_SCHEMA系统库锁相关数据表**

~~~sql
## 查看事务
select * from INFORMATION_SCHEMA.INNODB_TRX;
## 查看锁
select * from INFORMATION_SCHEMA.INNODB_LOCKS;
## 查看锁等待
select * from INFORMATION_SCHEMA.INNODB_LOCK_WAITS;
## 释放锁，trx_mysql_thread_id可以从INNODB_TRX表里查看到
kill trx_mysql_thread_id
## 查看锁等待详细信息
show engine innodb status\G; 
~~~

**锁优化**

+ 尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁
+ 合理设计索引，尽量缩小锁的范围
+ 尽可能减少检索条件范围，避免间隙锁
+ 尽量控制事务大小，减少锁定资源量和时间长度，设计事务加锁的sql精良存放在事务最后执行
+ 尽可能使用低级别事务隔离
