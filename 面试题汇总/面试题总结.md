# 你问我答

1. HashMap和HashTable的区别？
    >hashmap和hashtable都是用于实现键值对映射的数据结构，区别有：
    >线程安全：hashtable是线程安全的，即使在多线程的环境下也可以安全使用。而hashmap是线程不安全的，需要在多线程环境下进行同步。hashtable是通过sync实现线程安全的
    >性能：hashtable由于需要同步操作，所有性能上比hashmap差。在单线程环境下，hashmap通常比hashtable具有更好的性能。
    >空值：hashtable是不允许见过这值为null的，而hashtable是允许的。
    >继承关系：hashtable是dictionary的子类，hashmap是abstractmap的子类。

2. 为什么会产生死锁？

    > 死锁产生的原因是因为两个或多个线程无限期的等待对方释放资源，导致程序无法继续执行的情况。
    > 死锁通常发生在多线程环境中，当多个线程试图同时获得两个或多个共享资源的锁，并且获取的顺序不一致时，就可能产生死锁。当一个线程获得了一个锁，而另外一个线程试图获取相同的锁时，他就会阻塞，直到第一个线程释放锁。如果两个线程都在等待对方释放锁，就会无期限的等待下去，形成死锁。
    > 为了避免死锁的发生，应该尽量避免在一个线程持有锁的同时去等待另外一个锁，或者在一个线程等待锁时持有另外一个锁。此外还可以通过合理的锁定顺序，避免长时间持有锁，使用定时锁等方式来避免死锁的产生。

3. jvm类加载机制？

    > jvm的类加载机制是指jvm在运行时将类加载到内存中的过程。jvm的类加载机制是按需加载、动态加载和基于委派的机制加载。
    > 按需加载：jvm的类加载是按需加载的，即再程序运行时才加载需要使用的类，当一个类别第一次使用时加载到内存当中，以后就不会再加载了。
    > 动态加载：jvm支持动态加载类，在程序运行时可以通过class.forName()等反射机制动态加载类。
    > 基于委派的机制：jvm的类加载机制是基于委派的机制，当一个类需要被加载时，jvm首先会查找类加载器中是否已经加载了该类，如果已经加载则直接返回该类的class对象，否则就会将该类的加载请求委托给父类加载器，如果父类加载器没办法加载该类，则由当前类加载器进行加载。
    > jvm类加载机制可以分为三个步骤：加载、链接和初始化。
    >     加载：是将类文件中的字节码读入内存中，并创建一个代表该类的class对象，
    >     链接：是将二进制代码合并到jvm的运行状态中，
    >     初始化：是对类进行初始化，包括静态变量初始化，静态代码块执行等。

4. jvm内存模型？

    > ###### java虚拟机由三部分组成，类装在子系统，运行时数据区，字节码执行引擎。
    > 类装载子系统： 负责把字节码文件加载到运行时数据区。
    >
    > ###### 运行时数据区（内存模型）：
    >
    > + 程序计数器：程序技术区是一块较小的内存区域，它的作用是记录jvm当前线程所执行的字节码指令地址。当jvm执行java方法时，程序计数器记录当前线程执行的位置，当前线程执行完成后，计数器自动清零；
    > + java虚拟机栈：用于存储java方法执行过程中的局部变量表、操作数栈、方法出口等，每个线程执行java方法时都会创建一个对应的栈帧，并将栈帧压入线程栈中，当线程执行完毕后，栈帧将弹出并销毁；
    > + 本地方法栈：本地方法栈与线程栈类似，用于存储native方法的信息（用语言或其他的语言编写的方法）。
    > + 堆内存：用于存储java对象实例，所有的java对象都在堆中分配内存，堆内存时由垃圾回收器进行管理的。
    > + 方法区：用于存储类的元数据信息（如类名、方法名、字段名、字节码指令等）、常量池、静态变量等。方法区是线程的共享内存区域。
    > + 运行时常量池：运行时常量池是方法区的一部分，用于存储编译时生成的各种字面量和符号引用，也是线程共享的内存区域。
    >
    > 除以上6块区域外还有一个直接内存，它并不是运行时数据区的一部分，但是被频繁的使用在java nio中，用于存储缓存区。
    >
    > ###### 堆内存（java heap）
    >
    > java堆是java虚拟机管理的内存中最大的一块，用于存储对象实例和数组，是java程序的运行时数据区域之一，堆内存结构有：
    >
    > + 新生代：默认占整个堆内存的1/3。
    >
    >   + eden区：默认占年轻代的8/10。
    >   + survivor区：有survivor0和survivor1区，默认占年轻代的2/10。
    >
    >   新创建的对象首先会被分配到eden区，当eden区放满之后会触发一次gc（minor gc-不会触发stw），在gc的过程中，存活的对象会被移到survivor0中，下一次gc的时候会把eden区和survivor0区存活的对象移到survivor区中，没触发一次gc后存活的对象分代年龄会➕1，当分代年龄到达15时，存活的对象会被移到老年代中。
    >
    > + 老年代：用与存储存活时间比较长的对象，在大量对象经过几次minor gc之后，会逐渐被移到老年代中，当老年代空间不足时，则会触发一次full gc（会触发STW）。
    >
    > + ~~永久代~~：永久代被用于存储类的元数据信息，常量池等数据，在jdk1.8之后被元空间取代。
    >
    > + 元空间（metaspace）：是一块本地内存，用于存储类的元数据信息、常量池等数据。与堆空间分离，如果大小超过配置的最大大小时，则会触发一次full gc。

5. 垃圾回收机制？

    >+ jvm垃圾回收机制时指在java程序运行时，jvm自动回收不在使用的对象锁占用的内存空间的机制。垃圾回收机制可以帮助开发人员管理内存，避免内存泄漏等问题。
    >
    >  jvm垃圾回收机制的基本原理时检查内存中的对象，并识别哪些对象不在被程序所引用，这些不被引用的对象就可以被标记为垃圾对象，并被回收。垃圾回收机制具体方式有很多中，比较常见的有：
    >
    >  + 标记-清除算法：首先标记所有需要回收的垃圾对象，然后清除标记的内存空间，弊端就是会造成大量的碎片化内存区域，会导致内存分配时难以找到足够大的连续的内存空间。
    >  + 复制算法：复制算法时将内存分为两个相同的区域，每次只只用一块区域，当触发gc时会把存活的对象复制到另外一块区域，然后清除了整个内存区域的对象，这种算法的优点是回收率高，不会产生内存碎片，缺点是会产生额外的内存空间。
    >  + 标记整理：
    >  + 分代算法：

6. 项目中如何查看垃圾回收？

    >可以使用jconsole工具，可以监控垃圾回收的情况，还可以通过jstat -gc命令等

7. java反射获取私有属性，改变属性值？

    > 通过class.forname获取class对象，然后通过class.getdeclaredField()获取field对象。私有对象需要把accessible设置为true。然后使用field.set方法修改值。

8. 反射用途？

    >动态创建对象、获取类信息、操作私有属性和方法、运行时类型判断、动态代理、

9. 会什么算法？

2. 数据库乐观锁使用？

    > 数据库乐观锁是一种创建的解决并发问题的方法，他通过在数据表中添加一个版本号字段，来实现堆数据的并发控制。在使用乐观锁的情况下，每次对数据进行更新操作时都会检查当前版本号和数据库的版本号是否一致，如果一致则允许更新数据并将版本号➕1，如果不一致则认为数据已经被其他进程修改，则会更新失败。

11. 状态机

2. 如何解决状态机不对的问题？

1. 如何分库分表？

    >数据分库分表是一种常见的大数据量处理方案，通常用于处理大规模数据量，提高数据库性能和可扩展性。
    >
    >+ 数据库设计：首先要对数据库进行设计，包括表结构、索引、关系等，在设计的同时应该考虑到数据的访问模式，以及需要支持的查询和事务。
    >+ 数据库分库：再分库时，需要将数据按照一定的规则划分到多个物理库中，通常会通过数据量、访问模式等因素来确定分表策略。
    >+ 数据库分表：按照一定的规则把数据分散在多个物理表中，比如通过hash、时间等等。
    >+ 数据同步：由于数据要分散到多个物理库中，需要考虑到数据一致性问题。
    >+ 数据迁移：在进行分表分库时需要将现有的数据分布到新的数据库中，在这个过程中需要考虑到数据一致性问题。

1. 分布式事务解决方案》？

    >这些协议都是分布式系统中保证事务的一致性协议。
    >
    >+ 2PC ：2pc协议是一种经典的分布式事务协议，他涉及到两个阶段的条过程。在第一阶段，所有参与者都会向协调者发送准备就绪的信息，如果所有参与者都已准备就绪，则进入第二阶段，协调者向所有参与者发送提交信息，如果所有参与者都收到提交信息，则事务提交，否则事务回滚。
    >
    >+ 3PC：是在2pc的基础上增加了一个阶段，及超时等待机制，在第一阶段，所有参与者向协调者发送准备就绪的信息，第二阶段，协调者向所有参与者发送预提交信息，如果所有参与者都收到了预提交信息，则进入第三阶段，协调者向所有参与者发送提交信息，如果参与者都收到提交信息，则事务提交，否则进入超时等待阶段并回滚事务。
    >
    >+ TCC：tcc协议是一种补偿事务协议，与2pc和3pc不同，他采用了try- confirm-cancel三个阶段的提交过程。
    >
    >  + 第一阶段：资源的预留或检查操作被执行，这个阶段可能会失败；
    >  + 第二阶段：资源确认被执行，这个阶段不应该失败；
    >  + 第三阶段：资源的回滚操作被执行，这个阶段只有在第一阶段执行失败的情况下才会被执行。
    >
    >  tcc协议主要用于需要实现补偿机制的高并发分布式事务场景，例如电商系统的下单操作，库存预占的补偿操作。

15. mysql极限？

     >mysql是一种关系性数据库管理系统，可用于处理大量的数据和高并发请求，mysql没有明确的硬限制，但是影响性能和可伸缩性会受到很多因素的影响，比如硬件配置、数据库设计、查询语句的优化等等。
     >
     >+ 硬件配置：mysql性能取决于硬件的处理能力、存储能力和网络带宽等因素。如果硬件配置不足则会影响mysql的性能。
     >+ 数据库设计：数据库的设计也会影响到mysql的性能。比如说数据类型、索引，分区表等可以提高mysql的性能。
     >+ 查询语句的优化：查询语句的优化可以减少msql的负载和提高性能。例如争取的查询语句、避免使用自查询等可以提高mysql的性能。
     >+ 数据库服务器的优化：mysql服务器也可以通过一些配置选项进行优化，例如调整缓存池大小、连接线程池大小、查询缓存等。

1. HashMap源码？

    >

1. 设计一个线程安全的HashMap？

    >

1. ConcurrentHashMap底层原理？

    >

1. 手写一个lru（用linkedHashMap）

    >

1. jdk1.8中的HashMap为什么用红黑树不用普通的avl树？

    >

1. 为什么在8的时候链表变成红黑树？

    >

1. 为什么在6的时候从树退回链表？

    >

1. 线程池7个参数，该怎么配置最好？

    >

1. 说一下volatile？

    >

1. volatile的可见性和禁止指令重排是怎么实现的？

    >

1. synchronized关键字的用法？
    >
    
2. synchronized修饰方法和普通方法锁区别？
    获取类锁之后还能获取对象锁吗？
    >
    
3. CAS是什么？
    priorityQueue底层时什么？
    初始容量是多少？
    扩容方式？
    >
    
4. 若原始大小<64，则扩容为原理啊的2倍+2，不然扩容为原来的1.5倍
    >
    
5. HashMap的容量为什么要设置为2的次幂？
    >
    
6. HashMap在大量的哈希冲突该怎么处理？
    >
    
7. 你知道跳表吗？
    什么场景会用到跳表？
    >
    
8. CopyOnWriteArrayList知道吗？
    迭代器支持fail-fast吗？
    >
    
9. innodb的底层数据结构？
    >
    
10. 为什么用B+树而不用B树？
    >
    
11. 为什么用B+树而不用红黑树？
    >
    
12. 数据库的隔离界别和解决的问题？
    >
    
13. 数据库默认的隔离级别？一定会产生幻读吗？怎么解决？
    >
    
14. 快排的实现，时间复杂度和空间复杂度？
    >
    
15. 如何把项目变成SOA架构？
    >
    
16. spring源码，最深刻的模块，aop的用途？
    >
    
17. spring的aop实现？
    >
    
18. 浏览器输入网址过程，结合springmvc？
    >
    
19. 介绍redis？
    >
    
20. 如何将数据分布在不同的redis中？
    >
    
21. 字节码结构？
    >
    
22. 负载均衡的算法？
    >
    
23. 如何查看系统的负载？
    >
    
24. 对netty的了解？
    >
    
25. 谈谈中间件？
    >
    
26. 对zookeeper的理解？以及ZAB协议？

    >
